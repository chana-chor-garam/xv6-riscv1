xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
Version 6 (v6).  xv6 loosely follows the structure and style of v6,
but is implemented for a modern RISC-V multiprocessor using ANSI C.

ACKNOWLEDGMENTS

xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
2000)).  See also https://pdos.csail.mit.edu/6.1810/, which provides
pointers to on-line resources for v6.

The following people have made contributions: Russ Cox (context switching,
locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
Clements.

We are also grateful for the bug reports and patches contributed by
Abhinavpatel00, Takahiro Aoyagi, Marcelo Arroyo, Hirbod Behnam, Silas
Boyd-Wickizer, Anton Burtsev, carlclone, Ian Chen, clivezeng, Dan
Cross, Cody Cutler, Mike CAT, Tej Chajed, Asami Doi,Wenyang Duan,
echtwerner, eyalz800, Nelson Elhage, Saar Ettinger, Alice Ferrazzi,
Nathaniel Filardo, flespark, Peter Froehlich, Yakir Goaron, Shivam
Handa, Matt Harvey, Bryan Henry, jaichenhengjie, Jim Huang, Matúš
Jókay, John Jolly, Alexander Kapshuk, Anders Kaseorg, kehao95,
Wolfgang Keller, Jungwoo Kim, Jonathan Kimmitt, Eddie Kohler, Vadim
Kolontsov, Austin Liew, l0stman, Pavan Maddamsetti, Imbar Marinescu,
Yandong Mao, Matan Shabtay, Hitoshi Mitake, Carmi Merimovich,
mes900903, Mark Morrissey, mtasm, Joel Nider, Hayato Ohhashi,
OptimisticSide, papparapa, phosphagos, Harry Porter, Greg Price, Zheng
qhuo, Quancheng, RayAndrew, Jude Rich, segfault, Ayan Shafqat, Eldar
Sehayek, Yongming Shen, Fumiya Shigemitsu, snoire, Taojie, Cam Tenny,
tyfkda, Warren Toomey, Stephen Tu, Alissa Tung, Rafael Ubal, unicornx,
Amane Uehara, Pablo Ventura, Luc Videau, Xi Wang, WaheedHafez, Keiichi
Watanabe, Lucas Wolf, Nicolas Wolovick, wxdao, Grant Wu, x653, Andy
Zhang, Jindong Zhang, Icenowy Zheng, ZhUyU1997, and Zou Chang Wei.

ERROR REPORTS

Please send errors and suggestions to Frans Kaashoek and Robert Morris
(kaashoek,rtm@mit.edu).  The main purpose of xv6 is as a teaching
operating system for MIT's 6.1810, so we are more interested in
simplifications and clarifications than new features.

BUILDING AND RUNNING XV6

You will need a RISC-V "newlib" tool chain from
https://github.com/riscv/riscv-gnu-toolchain, and qemu compiled for
riscv64-softmmu.  Once they are installed, and in your shell
search path, you can run "make qemu".



--------------------(user definations)------------------

Implementing getreadcount() in xv6-riscv

This guide provides the necessary code changes and instructions to add a new system call, getreadcount, to your xv6-riscv kernel.
Step 1: Add a new system call number

Edit the file kernel/syscall.h. You need to add a new entry for SYS_getreadcount.

// File: kernel/syscall.h
#define SYS_fork    1
#define SYS_exit    2
#define SYS_wait    3
#define SYS_pipe    4
#define SYS_read    5
#define SYS_getreadcount 25 // Add this line

Step 2: Define the system call function and a global counter

Edit the file kernel/sysfile.c. You need to:

    Declare a global 64-bit integer to store the byte count.

    Implement the sys_getreadcount() function to return this counter's value.

    Modify the sys_read() function to increment the counter by the number of bytes read.

Step 3: Add the system call to the dispatch table

Edit the file kernel/syscall.c. You need to add the new system call function to the syscalls array.

// File: kernel/syscall.c
extern uint64 sys_getreadcount(void); // Add this declaration

static uint64 (*syscalls[])(void) = {
[SYS_fork]        sys_fork,
[SYS_exit]        sys_exit,
[SYS_wait]        sys_wait,
[SYS_pipe]        sys_pipe,
[SYS_read]        sys_read,
[SYS_getreadcount] sys_getreadcount, // Add this entry
};

Step 4: Expose the system call to user space

Edit the file user/user.h. This allows user programs to call the new system call. Add the following function declaration:

// File: user/user.h
int getreadcount(void);

Step 5: Create a new user program to test the system call

Create a new file user/readcount.c and add the code provided below. This program will test the functionality of your new system call.
Step 6: Add the user program to the Makefile

Edit the file Makefile. Add readcount to the UPROGS list.

// File: Makefile
UPROGS=\
    ...
    _readcount\
    ...

Step 7: Compile and Run

    From the xv6-riscv directory, run make qemu.

    Once the xv6 shell starts, type readcount and press Enter.

The output should show the counter increasing by 100 after the read operation.

